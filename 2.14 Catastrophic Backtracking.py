# 2.14 Catastrophic Backtracking
""""""
import re
string = ''


"""
Если к группе применён квантификатор и внутри этой группы используется ещё один квантификатор 
или |, то регулярное выражение может быть неконтролируемым.
Примеры регулярных выражений, которые попадают под catastrophic backtracking:
(?:a+)+
([a-zA-Z_]+)*
(?:a|aa)+
(a|a?)+


* * * * *   Притяжательные квантификаторы  * * * * *
Если после жадного квантификатора поставить +, то он станет притяжательным:
{m,n}+
{,n}+
{m,}+
*+
++
?+
Притяжательные квантификаторы, как и жадные, пытаются найти максимально возможное количество вхождений. 
Но, в отличие от жадных квантификаторов, они не разрешают back-tracking, 
когда регулярное выражение не может найти совпадение.
Это значит, что движок не будет проходить огромное количество путей и закончит свою работу раньше, 
если совпадение не будет найдено.
Как и в случае с ленивыми квантификаторами, смысла делать квантификатор {n} притяжательным нет


* * * * *   Атомарная группировка  * * * * *
Второе решение проблемы с catastrophic backtracking - атомарная группировка:
(?>regex)
Если совпадения найдены - движок регулярных выражений пытается найти 
совпадения для оставшейся части регулярного выражения, 
следующего после атомарной группировки. Если совпадений нет - 
движок регулярных выражения может откатиться назад только на место до атомарной группировки (?>regex)

Например, выражение (?>.*). никогда не найдёт совпадений, потому что шаблон .* 
нашёл бы все возможные символы в тексте, и оставшаяся . не смогла бы найти совпадение.

x{m,n}+ одно и то же, что и (?>x{m,n})
x*+ одно и то же, что и (?>x*)
x++ одно и то же, что и (?>x+)
x?+ одно и то же, что и (?>x?)
"""


# Task 01
"""
Исправьте регулярное выражение, не используя атомарную группировку и притяжательные квантификаторы, 
чтобы у него не было Catastrophic Backtracking.
regex = r'(?:a+)+b'
"""
regex = r'(?:a+)b'
regex = r'a+b'


# Task 02
"""
Исправьте следующее регулярное выражение с помощью атомарной группировки или притяжательных квантификаторов, 
чтобы у него не было Catastrophic Backtracking:
Если программа сразу же выводит в консоль пустой список [] 
и в регулярном выражении используются притяжательные квантификаторы или атомарная группировка, 
то задание считается выполнеым.
"""
regex = r'(?:a)+b'
print(re.findall(regex, 'a'*50))  # []
